{"version":3,"sources":["../../src/where.ts"],"sourcesContent":["import { Query } from \"./query.js\";\nimport { Select } from \"./select.js\";\nimport { Join } from \"./join.js\";\n\ntype Condition<T extends object> = {\n  [K in keyof T]?: T[K] | { $eq: T[K] } | { $gt: T[K] } | { $lt: T[K] } | { $gte: T[K] } | { $lte: T[K] } | { $ne: T[K] } | { $in: T[K][] } | { $like: string };\n}\n\nexport type WhereCondition<T extends object> = Condition<T> & {\n  \"or\"?: Array<Condition<T>>;\n};\n\nexport type OrCondition<T extends object> = {\n  type: 'or';\n  conditions: Condition<T>;\n};\n\nexport class Where<T extends object> implements Query<T> {\n  readonly query: Query<T>;\n  readonly conditions: WhereCondition<T>;\n  readonly orConditions: OrCondition<T>[] = [];\n\n  constructor(query: Query<T>, conditions: WhereCondition<T>, orConditions: OrCondition<T>[] = []) {\n    this.query = query;\n    this.conditions = conditions;\n    this.orConditions = orConditions;\n  }\n\n  select(fields: Array<keyof T>): Select<T>;\n  select(fields: Partial<Record<keyof T, string>>): Select<T>;\n  select(subquery: Query<any>, alias?: string): Select<T>;\n  select(fields: Array<keyof T> | Partial<Record<keyof T, string>> | Query<any>, alias?: string): Select<T> {\n    return new Select<T>(this, fields, alias);\n  }\n\n  join<U extends object>(tableName: string, tableAlias?: string): Join<T, U> {\n    const newQuery = new BaseQuery<U>(tableName, tableAlias);\n    return new Join<T, U>(this, newQuery, 'INNER');\n  }\n\n  innerJoin<U extends object>(tableName: string, tableAlias?: string): Join<T, U> {\n    return this.join<U>(tableName, tableAlias);\n  }\n\n  leftJoin<U extends object>(tableName: string, tableAlias?: string): Join<T, U> {\n    const newQuery = new BaseQuery<U>(tableName, tableAlias);\n    return new Join<T, U>(this, newQuery, 'LEFT');\n  }\n\n  where(conditions: WhereCondition<T>): Where<T> {\n    // Merge conditions (simple approach - in real implementation might want more sophisticated merging)\n    const mergedConditions = { ...this.conditions, ...conditions };\n    return new Where<T>(this.query, mergedConditions, this.orConditions);\n  }\n\n  or(conditions: Condition<T>): Where<T> {\n    const orCondition: OrCondition<T> = {\n      type: 'or',\n      conditions\n    };\n    const newOrConditions = [...this.orConditions, orCondition];\n    return new Where<T>(this.query, this.conditions, newOrConditions);\n  }\n}\n\n// Need to import BaseQuery here to avoid circular dependency\nimport { BaseQuery } from \"./query.js\";\n"],"names":["Select","Join","Where","select","fields","alias","join","tableName","tableAlias","newQuery","BaseQuery","innerJoin","leftJoin","where","conditions","mergedConditions","query","orConditions","or","orCondition","type","newOrConditions"],"mappings":";;;;;;;;;;;;;AACA,SAASA,MAAM,QAAQ,cAAc;AACrC,SAASC,IAAI,QAAQ,YAAY;AAejC,OAAO,MAAMC;IAcXC,OAAOC,MAAsE,EAAEC,KAAc,EAAa;QACxG,OAAO,IAAIL,OAAU,IAAI,EAAEI,QAAQC;IACrC;IAEAC,KAAuBC,SAAiB,EAAEC,UAAmB,EAAc;QACzE,MAAMC,WAAW,IAAIC,UAAaH,WAAWC;QAC7C,OAAO,IAAIP,KAAW,IAAI,EAAEQ,UAAU;IACxC;IAEAE,UAA4BJ,SAAiB,EAAEC,UAAmB,EAAc;QAC9E,OAAO,IAAI,CAACF,IAAI,CAAIC,WAAWC;IACjC;IAEAI,SAA2BL,SAAiB,EAAEC,UAAmB,EAAc;QAC7E,MAAMC,WAAW,IAAIC,UAAaH,WAAWC;QAC7C,OAAO,IAAIP,KAAW,IAAI,EAAEQ,UAAU;IACxC;IAEAI,MAAMC,UAA6B,EAAY;QAC7C,oGAAoG;QACpG,MAAMC,mBAAmB;YAAE,GAAG,IAAI,CAACD,UAAU;YAAE,GAAGA,UAAU;QAAC;QAC7D,OAAO,IAAIZ,MAAS,IAAI,CAACc,KAAK,EAAED,kBAAkB,IAAI,CAACE,YAAY;IACrE;IAEAC,GAAGJ,UAAwB,EAAY;QACrC,MAAMK,cAA8B;YAClCC,MAAM;YACNN;QACF;QACA,MAAMO,kBAAkB;eAAI,IAAI,CAACJ,YAAY;YAAEE;SAAY;QAC3D,OAAO,IAAIjB,MAAS,IAAI,CAACc,KAAK,EAAE,IAAI,CAACF,UAAU,EAAEO;IACnD;IAxCA,YAAYL,KAAe,EAAEF,UAA6B,EAAEG,eAAiC,EAAE,CAAE;QAJjG,uBAASD,SAAT,KAAA;QACA,uBAASF,cAAT,KAAA;QACA,uBAASG,gBAAiC,EAAE;QAG1C,IAAI,CAACD,KAAK,GAAGA;QACb,IAAI,CAACF,UAAU,GAAGA;QAClB,IAAI,CAACG,YAAY,GAAGA;IACtB;AAqCF;AAEA,6DAA6D;AAC7D,SAASP,SAAS,QAAQ,aAAa"}